# S/KEY Melnikov Dorofeev 9317{23,24}

## Описание алгоритма

1. Вначале и клиент, и сервер нужно настроить на единую парольную фразу. Далее клиент отправляет серверу пакет инициализации, а сервер в ответ отправляет порядковый номер и случайное число - «зерно» (seed).
2. Клиент вводит секретную парольную фразу. Парольная фраза соединяется с «зерном», полученным от сервера в открытом виде. «Зерно» дает клиенту возможность использовать одну и ту же парольную фразу на множестве машин с разными «зернами».
3. Клиент многократно использует хэш-функцию и получает 64-разрядную итоговую величину. При каждом новом использовании количество хэш-циклов уменьшается на один.
4. Клиент передает одноразовый пароль на сервер, где он и проверяется. На сервере есть файл, в котором хранится одноразовый пароль, использованный в последнем успешном сеансе связи с каждым отдельным пользователем. Для проверки  система однократно пропускает полученный одноразовый пароль через хэш-функцию. Если результат этой операции совпадает с предыдущим паролем, хранящимся в файле, результат аутентификации считается положительным, а новый пароль сохраняется для дальнейшего использования.
5. Пользователь может инициализировать систему с помощью команды keyinit, которая дает возможность изменить секретную парольную фразу, количество циклов итерации и «зерно».


## Спецификация протокола

- Используемый язык -- Go. Для обмена данными используются сокеты
- Используемая хэш-функция -- MD5
- Размер передаваемого блока всегда 128 бит
- Парольная фраза изначально определена в коде клиента и сервера
- Число итераций `n` = 1000 (при локальных тестах = 10)


## Стандартный сценарий протокола


### Инициализация общения

- Клиент инициирует общение с сервером, посылая сообщение `hello`
- Сервер отправляет двумя сообщениями: `id` клиента и случайный `seed`
- Оба вырабатывают пароли для всех будущих идентификаций
- Далее клиент начинает отправлять сообщения

### Передача сообщений

Информация передаётся кусками по 128 бит. Порядок передачи следующий:

1. Пароль i-ой итерции
2. Сообщение, разбитое на блоки по 128 бит
3. Пустой кусок, как окончание передачи сообщения
	
### Обновление seed

В случае, если число итерации закончилось, а клиенту всё ещё нужно продолжить общение с сервером, то они меняют seed и вырабатывают ещё 1000 одноразовых паролей

Как это происходит: как только сервер использовал последний одноразовый ключ, он рандомит новый seed и отправляет его клиенту. Клиент принимает seed и оба пересчитывают пароли. Далее клиент продолжает передачу сообщений
